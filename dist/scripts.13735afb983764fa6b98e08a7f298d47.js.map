{"version":3,"file":"scripts.xxxxxxxxxxxxxxxxxxxx.js","mappings":";;;;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,+EAA+E,sBAAsB;AACrG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,cAAc;AACd;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA,sBAAsB;AACtB;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,aAAa;AACb,SAAS;;AAET;AACA;AACA;AACA,cAAc;AACd;AACA;;AAEA;AACA,SAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL,CAAC","sources":["webpack:///./resources/js/scripts.js"],"sourcesContent":["\ndocument.addEventListener('alpine:init', () => {\n    let _nextUploadTime = 0\n    let _dropzoneDisabled = false\n\n    function _handleDropzone(container, dropCallback) {\n        container.addEventListener('dragover', (e) => {\n            e.preventDefault()\n\n            if (! _dropzoneDisabled) {\n                container.classList.add('luh__dropzone-dragging')\n            }\n        })\n\n        container.addEventListener('dragleave', (e) => {\n            container.classList.remove('luh__dropzone-dragging')\n        })\n\n        container.addEventListener('drop', (e) => {\n            e.preventDefault()\n            container.classList.remove('luh__dropzone-dragging')\n\n            if (! _dropzoneDisabled) {\n                dropCallback(e)\n            }\n        })\n    }\n\n    function _validateFile(file, errors, $wire) {\n        if ($wire.acceptsMimeTypes.length > 0 && ! $wire.acceptsMimeTypes.includes(file.type)) {\n            errors[file.name] = window.livewireUploadHandlerParams.invalidFileTypeErrorMessage\n            return false\n        }\n\n        if ($wire.maxFileSize !== null && file.size > $wire.maxFileSize) {\n            errors[file.name] = window.livewireUploadHandlerParams.fileTooLoudErrorMessage\n            return false\n        }\n\n        return true\n    }\n\n    function _waitBeforeNextUpload() {\n        _nextUploadTime = Math.max(_nextUploadTime, Date.now())\n        const timeToWait = _nextUploadTime - Date.now()\n        _nextUploadTime += 1050\n\n        return new Promise(r => setTimeout(r, timeToWait))\n    }\n\n    function _compressImage(file, settings) {\n        const compressorjs = eval(window.livewireUploadHandlerParams.compressorjsVar);\n\n        if (! compressorjs || ! file.type.startsWith('image/')) {\n            return file\n        }\n\n        return new Promise((resolve, reject) => {\n            settings.success = resolve\n            settings.error = reject\n\n            new compressorjs(file, settings)\n        })\n    }\n\n    // ALPINE COMPONENT FOR GROUP\n    // =========================================================================\n\n    Alpine.data('LivewireUploadHandlerGroup', ($wire) => ({\n        groupErrors: {},\n        filesFromGroup: [],\n        nbRunningActions: {\n            group: 0,\n            items: 0,\n        },\n        queuedActions: {\n            group: [],\n            items: [],\n        },\n        sortablejsObj: null,\n        itemsIncrementInProgress: false,\n\n        initDropzone() {\n            _handleDropzone(this.$el, (e) => {\n                this.upload(e.dataTransfer.files)\n            })\n        },\n\n        initSortable() {\n            const sortablejs = eval(window.livewireUploadHandlerParams.sortablejsVar)\n            const that = this\n\n            if (! sortablejs || ! $wire.sortable) {\n                return\n            }\n\n            this.sortablejsObj = new sortablejs(this.$el, {\n                draggable: '.luh__sort-draggable',\n                handle: '.luh__sort-handle',\n                animation: 150,\n                onStart(e) {\n                    _dropzoneDisabled = true\n                },\n                onEnd(e) {\n                    const previousItem = e.item.previousSibling.previousSibling\n\n                    if (previousItem !== null && previousItem.nodeValue === '[if ENDBLOCK]><![endif]') {\n                        previousItem.before(e.item)\n                    }\n\n                    _dropzoneDisabled = false\n                },\n                store: {\n                    set(sort) {\n                        that.sortablejsObj.option('disabled', true)\n\n                        that._waitItemsActions(async () => {\n                            await $wire.sortItems(sort.toArray())\n                            that.sortablejsObj.option('disabled', false)\n                        })\n                    }\n                }\n            })\n        },\n\n        itemHidden(itemId) {\n            if (! $wire.autoSave && $wire.items[itemId].id !== null) {\n                return false\n            }\n\n            return $wire.items[itemId].deleted\n        },\n\n        visibleItemsNumber() {\n            return Object.keys($wire.items).filter(itemId => ! this.itemHidden(itemId)).length\n        },\n\n        maxFilesNumberReached() {\n            if ($wire.maxFilesNumber <= 0) {\n                return false\n            }\n\n            return this.visibleItemsNumber() >= $wire.maxFilesNumber\n        },\n\n        async upload(files) {\n            if (this.itemsIncrementInProgress) {\n                return\n            }\n\n            this.filesFromGroup = []\n            this.itemsIncrementInProgress = true\n            this.groupErrors = {}\n\n            for (let file of files) {\n                file = await _compressImage(file, $wire.compressorjsSettings)\n\n                if (_validateFile(file, this.groupErrors, $wire)) {\n                    this.filesFromGroup.push(file)\n                }\n            }\n\n            const nbFilesFromGroup = this.filesFromGroup.length\n            let nbFilesToAdd = nbFilesFromGroup\n\n            if ($wire.maxFilesNumber > 0) {\n                for (let i = $wire.maxFilesNumber - this.visibleItemsNumber(); i < nbFilesFromGroup; i++) {\n                    this.groupErrors[this.filesFromGroup[i].name] = window.livewireUploadHandlerParams.maxFilesNumberReachedMessage\n                    nbFilesToAdd--\n                }\n            }\n\n            this._waitItemsActions(async () => {\n                this.sortablejsObj?.option('disabled', true)\n                await $wire.incrementItems(nbFilesToAdd)\n                this.sortablejsObj?.option('disabled', false)\n                this.itemsIncrementInProgress = false\n            })\n        },\n\n        _waitItemsActions(groupAction) {\n            this._coordinateActions('group', groupAction)\n        },\n\n        async _coordinateActions(key, action) {\n            const otherKey = (key === 'group' ? 'items' : 'group')\n\n            if (this.nbRunningActions[otherKey] > 0) {\n                this.queuedActions[key].unshift(action)\n                return\n            }\n\n            this.nbRunningActions[key]++\n            await action()\n            this.nbRunningActions[key]--\n\n            if (this.nbRunningActions[key] <= 0) {\n                while (this.queuedActions[otherKey].length > 0) {\n                    this._coordinateActions(otherKey, this.queuedActions[otherKey].pop())\n                }\n            }\n        }\n    }))\n\n    // ALPINE COMPONENT FOR ITEM\n    // =========================================================================\n\n    Alpine.data('LivewireUploadHandlerItem', ($wire) => ({\n        itemErrors: {},\n        uploading: false,\n        uploadingFileOriginalName: null,\n        chunkIndex: 0,\n        uploadedSizeByChunk: [],\n        deleted: false,\n        deleteTimer: null,\n        deleteTimerInterval: null,\n\n        init() {\n            if ($wire.uploadFromGroupAtIndex !== null) {\n                this.upload(this.filesFromGroup[$wire.uploadFromGroupAtIndex])\n            }\n\n            this.deleted = $wire.itemData.deleted ?? false\n        },\n\n        initDropzone() {\n            _handleDropzone(this.$el, (e) => {\n                this.upload(e.dataTransfer.files[0])\n            })\n        },\n\n        uploadProgressValue() {\n            if (! $wire.uploadingFileSize) {\n                return 0\n            }\n\n            return Math.round(this.uploadedSizeByChunk.reduce((a, b) => a + b, 0) * 100 / $wire.uploadingFileSize)\n        },\n\n        async upload(file) {\n            this.itemErrors = {}\n\n            try {\n                if (! $wire.attachedToGroup) {\n                    file = await _compressImage(file, $wire.compressorjsSettings)\n                }\n\n                if (! _validateFile(file, this.itemErrors, $wire)) {\n                    return\n                }\n\n                this.uploading = true\n                this.uploadingFileOriginalName = file.name\n                this.chunkIndex = 0\n                this.uploadedSizeByChunk = []\n                this.deleted = false\n                $wire.uploadingFileSize = file.size\n                $wire.hasErrorOnUpload = false\n                this._uploadChunk(file, 0)\n\n            } catch (error) {\n                this._errorOnUpload()\n            }\n        },\n\n        cancelUpload() {\n            this._waitGroupActions(() => {\n                this.uploading = false\n                $wire.itemData.deleted = ($wire.savedFilePath === null)\n                $wire.cancelUpload('chunkFile')\n                return $wire.deleteUploadingFile()\n            })\n        },\n\n        deleteUploadedFile() {\n            this._waitGroupActions(() => {\n                $wire.itemData.deleted = ($wire.savedFilePath === null)\n                return $wire.deleteUploadedFile()\n            })\n        },\n\n        deleteSavedFile(delay = 3) {\n            this.deleted = true\n\n            if (! $wire.autoSave) {\n                $wire.itemData.deleted = true\n                return\n            }\n\n            const applyDelete = () => {\n                this._waitGroupActions(() => {\n                    $wire.itemData.deleted = true\n                    return $wire.deleteSavedFile()\n                })\n            }\n\n            if (delay <= 0) {\n                applyDelete()\n                return\n            }\n\n            this.deleteTimer = delay\n\n            this.deleteTimerInterval = setInterval(() => {\n                if (this.deleteTimer > 1) {\n                    this.deleteTimer--\n                } else {\n                    clearInterval(this.deleteTimerInterval)\n                    applyDelete()\n                }\n            }, 1000)\n        },\n\n        undeleteSavedFile() {\n            clearInterval(this.deleteTimerInterval)\n            this.deleted = false\n            $wire.itemData.deleted = false\n        },\n\n        async _uploadChunk(originalFile, chunkStart) {\n            if (! this.uploading) {\n                return\n            }\n\n            this._waitGroupActions(async () => {\n                const chunkEnd = Math.min(chunkStart + window.livewireUploadHandlerParams.chunkSize, originalFile.size)\n                const chunkFile = originalFile.slice(chunkStart, chunkEnd, originalFile.type)\n                chunkFile.name = originalFile.name\n\n                await _waitBeforeNextUpload()\n\n                $wire.upload('chunkFile', chunkFile, () => {\n                    if ($wire.hasErrorOnUpload) {\n                        this._errorOnUpload()\n                        return\n                    }\n\n                    this.uploading &= chunkEnd < originalFile.size\n\n                    if (this.uploading) {\n                        this.chunkIndex++\n                        this._uploadChunk(originalFile, chunkEnd)\n\n                    } else if ($wire.onlyUpload) {\n                        $wire.itemData.deleted = true\n                    }\n                }, () => {\n                    this._errorOnUpload()\n                }, (event) => {\n                    this.uploadedSizeByChunk[this.chunkIndex] = chunkFile.size * event.detail.progress / 100\n                })\n            })\n        },\n\n        _errorOnUpload() {\n            if ($wire.attachedToGroup && $wire.savedFilePath === null) {\n                this.groupErrors[this.uploadingFileOriginalName] = window.livewireUploadHandlerParams.uploadErrorMessage\n            } else {\n                this.itemErrors[this.uploadingFileOriginalName] = window.livewireUploadHandlerParams.uploadErrorMessage\n            }\n\n            this.cancelUpload()\n        },\n\n        _waitGroupActions(itemAction) {\n            if (! $wire.attachedToGroup) {\n                itemAction()\n                return\n            }\n\n            this._coordinateActions('items', itemAction)\n        }\n    }))\n})\n"],"names":[],"sourceRoot":""}